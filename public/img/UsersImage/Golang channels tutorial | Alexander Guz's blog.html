<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Golang channels tutorial | Alexander Guz's blog</title>
	<meta name="author" content="Alexander Guz">
	<meta name="description" content="Golang channels tutorial">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="Golang%20channels%20tutorial%20|%20Alexander%20Guz's%20blog_files/style.css" type="text/css">
	<link rel="stylesheet" href="Golang%20channels%20tutorial%20|%20Alexander%20Guz's%20blog_files/pygments.css" type="text/css">
<script type="text/javascript" async="" src="Golang%20channels%20tutorial%20|%20Alexander%20Guz's%20blog_files/ga.js"></script><script src="Golang%20channels%20tutorial%20|%20Alexander%20Guz's%20blog_files/embed.js" data-timestamp="1578252174488"></script><link rel="prefetch" as="style" href="Golang%20channels%20tutorial%20|%20Alexander%20Guz's%20blog_files/a_data/lounge.css"><link rel="prefetch" as="script" href="Golang%20channels%20tutorial%20|%20Alexander%20Guz's%20blog_files/a_data/common.js"><link rel="prefetch" as="script" href="Golang%20channels%20tutorial%20|%20Alexander%20Guz's%20blog_files/a_data/lounge.js"><link rel="prefetch" as="script" href="Golang%20channels%20tutorial%20|%20Alexander%20Guz's%20blog_files/a_data/config.js"></head>
<body>

<section class="container">
	<nav class="menu">
		<ul>
			<li><a href="https://guzalexander.com/">home</a></li>
			<li><a href="https://guzalexander.com/archive/">archive</a></li>
			<li><a href="https://guzalexander.com/projects/">projects</a></li>
			<li><a href="http://feeds.feedburner.com/GuzAlexander">feed</a></li>
			<li><a href="https://guzalexander.com/about/">about</a></li>
		</ul>
	</nav>

	<section class="main">
		<h1>Golang channels tutorial</h1>
<time>December 6, 2013</time>
<article><p><a href="http://golang.org/">Golang</a> has built-in instruments for writing concurrent programs. Placing a <a href="http://golang.org/ref/spec#Go_statements">go</a>
 statement before a function call starts the execution of that function 
as an independent concurrent thread in the same address space as the 
calling code. Such thread is called <code class="language-plaintext highlighter-rouge">goroutine</code>
 in Golang. Here I should mention that concurrently doesn’t always mean 
in parallel. Goroutines are means of creating concurrent architecture of
 a program which could possibly execute in parallel in case the hardware
 allows it. There is a great talk on that topic <a href="http://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not parallelism</a>.</p>

<p>Let’s start with an example of a goroutine:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="c">// Start a goroutine and execute println concurrently</span>
     <span class="k">go</span> <span class="nb">println</span><span class="p">(</span><span class="s">"goroutine message"</span><span class="p">)</span>
     <span class="nb">println</span><span class="p">(</span><span class="s">"main function message"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>This program will print <code class="language-plaintext highlighter-rouge">main function message</code> and <em>possibly</em> <code class="language-plaintext highlighter-rouge">goroutine message</code>. I say <em>possibly</em> because spawning a goroutine has some peculiarities. When you start a goroutine the calling code (in our case it is the <code class="language-plaintext highlighter-rouge">main</code> function) doesn’t wait for a goroutine to finish, but continues running further. After calling a <code class="language-plaintext highlighter-rouge">println</code>
 the main  function ends its execution and in Golang it means stopping 
of execution of the whole program with all spawned goroutines. But 
before it happens our goroutine could possibly finish executing its code
 and print the <code class="language-plaintext highlighter-rouge">goroutine message</code> string.</p>

<p>As you understand there must be some way to avoid such situations. And for that there are <strong>channels</strong> in Golang.</p>

<h2 id="channels-basics">Channels basics<a class="header-link" href="#channels-basics"><i class="fa fa-link"></i></a></h2>

<p>Channels serve to synchronize execution of concurrently running 
functions and to provide a mechanism for their communication by passing a
 value of a specified type. Channels have several characteristics: the 
type of element you can send through a channel, capacity (or buffer 
size) and direction of communication specified by a <code class="language-plaintext highlighter-rouge">&lt;-</code> operator. You can allocate a channel using the built-in function <a href="http://golang.org/ref/spec#Making_slices_maps_and_channels">make</a>:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="n">i</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>       <span class="c">// by default the capacity is 0</span>
<span class="n">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span> <span class="c">// non-zero capacity</span>

<span class="n">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>          <span class="c">// can only read from</span>
<span class="n">w</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="o">&lt;-</span> <span class="p">[]</span><span class="n">os</span><span class="o">.</span><span class="n">FileInfo</span><span class="p">)</span> <span class="c">// can only write to</span></code></pre></figure>

<p>Channels are first-class values and can be used anywhere like other 
values: as struct elements, function arguments, function returning 
values and even like a type for another channel:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// a channel which:</span>
<span class="c">//  - you can only write to</span>
<span class="c">//  - holds another channel as its value</span>
<span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="o">&lt;-</span> <span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>

<span class="c">// function accepts a channel as a parameter</span>
<span class="k">func</span> <span class="n">readFromChannel</span><span class="p">(</span><span class="n">input</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{}</span>

<span class="c">// function returns a channel</span>
<span class="k">func</span> <span class="n">getChannel</span><span class="p">()</span> <span class="k">chan</span> <span class="kt">bool</span> <span class="p">{</span>
     <span class="n">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">b</span>
<span class="p">}</span></code></pre></figure>

<p>For writing and reading operations on channel there is a <a href="http://golang.org/ref/spec#Receive_operator">&lt;-</a>
 operator. Its position relatively to the channel variable determines 
whether it will be a read or a write operation. The following example 
demonstrates its usage, but I have to warn you that this code <strong>does not work</strong> for some reasons described later:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
     <span class="n">c</span> <span class="o">&lt;-</span> <span class="m">42</span>    <span class="c">// write to a channel</span>
     <span class="n">val</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c</span> <span class="c">// read from a channel</span>
     <span class="nb">println</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>Now, as we know what channels are, how to create them and perform 
basic operations on them, let’s return to our very first example and see
 how channels can help us.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="c">// Create a channel to synchronize goroutines</span>
     <span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>

     <span class="c">// Execute println in goroutine</span>
     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="nb">println</span><span class="p">(</span><span class="s">"goroutine message"</span><span class="p">)</span>

          <span class="c">// Tell the main function everything is done.</span>
          <span class="c">// This channel is visible inside this goroutine because</span>
          <span class="c">// it is executed in the same address space.</span>
          <span class="n">done</span> <span class="o">&lt;-</span> <span class="no">true</span>
     <span class="p">}()</span>

     <span class="nb">println</span><span class="p">(</span><span class="s">"main function message"</span><span class="p">)</span>
     <span class="o">&lt;-</span><span class="n">done</span> <span class="c">// Wait for the goroutine to finish</span>
<span class="p">}</span></code></pre></figure>

<p>This program will print both messages without any possibilities. Why? <code class="language-plaintext highlighter-rouge">done</code>
 channel has no buffer (as we did not specify its capacity). All 
operations on unbuffered channels block the execution until both sender 
and receiver are ready to communicate. That’s why unbuffered channels 
are also called synchronous. In our case the reading operation <code class="language-plaintext highlighter-rouge">&lt;-done</code>
 in the main function will block its execution until the goroutine will 
write data to the channel. Thus the program ends only after the reading 
operation succeeds.</p>

<p>In case a channel has a buffer all read operations succeed without 
blocking if the buffer is not empty, and write operations - if the 
buffer is not full. These channels are called asynchronous. Here is an 
example to demonstrate the difference between them:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">message</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c">// no buffer</span>
     <span class="n">count</span> <span class="o">:=</span> <span class="m">3</span>

     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
               <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"send message"</span><span class="p">)</span>
               <span class="n">message</span> <span class="o">&lt;-</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"message %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
          <span class="p">}</span>
     <span class="p">}()</span>

     <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span> <span class="o">*</span> <span class="m">3</span><span class="p">)</span>

     <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
          <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">message</span><span class="p">)</span>
     <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In this example <code class="language-plaintext highlighter-rouge">message</code> is a synchronous channel and the output of the program is:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">send message
// wait for 3 seconds
message 1
send message
send message
message 2
message 3</code></pre></figure>

<p>As you see after the first write to the channel in the goroutine all 
other writing operations on that channel are blocked until the first 
read operation is performed (about 3 seconds later).</p>

<p>Now let’s provide a buffer to out <code class="language-plaintext highlighter-rouge">message</code> channel, i.e. the creation line will look as  <code class="language-plaintext highlighter-rouge">message := make(chan string, 2)</code>. This time the output will be the following:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">send message
send message
send message
// wait for 3 seconds
message 1
message 2
message 3</code></pre></figure>

<p>Here we see that all writing operations are performed without waiting
 for the first read for the buffer of the channel allows to store all 
three messages. By changing channels capacity we can control the amount 
of information being processed thus limiting throughput of a system.</p>

<h2 id="deadlock">Deadlock<a class="header-link" href="#deadlock"><i class="fa fa-link"></i></a></h2>

<p>Now let’s get back to our not working example with read/write operations.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
     <span class="n">c</span> <span class="o">&lt;-</span> <span class="m">42</span>    <span class="c">// write to a channel</span>
     <span class="n">val</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c</span> <span class="c">// read from a channel</span>
     <span class="nb">println</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>On running you’ll get this error (details will differ):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
     /fullpathtofile/channelsio.go:5 +0x54
exit status 2</code></pre></figure>

<p>The error you got is called a <strong>deadlock</strong>. This is a 
situation when two goroutines wait for each other and non of them can 
proceed its execution. Golang can detect deadlocks in runtime that’s why
 we can see this error. This error occurs because of the blocking nature
 of communication operations.</p>

<p>The code here runs within a single thread, line by line, successively. The operation of writing to the channel (<code class="language-plaintext highlighter-rouge">c &lt;- 42</code>)
 blocks the execution of the whole program because, as we remember, 
writing operations on a synchronous channel can only succeed in case 
there is a receiver ready to get this data. And we create the receiver 
only in the next line.</p>

<p>To make this code work we should had written something like:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
     
     <span class="c">// Make the writing operation be performed in</span>
     <span class="c">// another goroutine.</span>
     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> 
     	<span class="n">c</span> <span class="o">&lt;-</span> <span class="m">42</span> 
     <span class="p">}()</span>
     <span class="n">val</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c</span>
     <span class="nb">println</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<h2 id="range-channels-and-closing">Range channels and closing<a class="header-link" href="#range-channels-and-closing"><i class="fa fa-link"></i></a></h2>

<p>In one of the previous examples we sent several messages to a channel and then read them. The receiving part of code was:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
	 <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">message</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>In order to perform reading operations without getting a deadlock we have to know the exact number of sent messages (<code class="language-plaintext highlighter-rouge">count</code>,
 to be exact), because we cannot read more then we sent. But it’s not 
quite convenient. It would be nice to be able to write more general 
code.</p>

<p>In Golang there is a so called <strong>range expression</strong> 
which allows to iterate through arrays, strings, slices, maps and 
channels. For channels, the iteration proceeds until the channel is 
closed. Consider the following example (does not work for now):</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">message</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span>
     <span class="n">count</span> <span class="o">:=</span> <span class="m">3</span>

     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
               <span class="n">message</span> <span class="o">&lt;-</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"message %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
          <span class="p">}</span>
     <span class="p">}()</span>

     <span class="k">for</span> <span class="n">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">message</span> <span class="p">{</span>
          <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
     <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Unfortunately this code does not work now. As was mentioned above the <code class="language-plaintext highlighter-rouge">range</code> will work until the channel is closed explicitly. All we have to do is to close the channel with a  <a href="http://golang.org/ref/spec#Close">close</a> function. The goroutine will look like:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
          <span class="n">message</span> <span class="o">&lt;-</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"message %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	 <span class="p">}</span>
     <span class="nb">close</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<span class="p">}()</span></code></pre></figure>

<p>Closing a channel has one more useful feature - reading operations on
 closed channels do not block and always return default value for a 
channel type:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>
<span class="nb">close</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>

<span class="c">// Will not block and will print false twice </span>
<span class="c">// because it’s the default value for bool type</span>
<span class="nb">println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">done</span><span class="p">)</span>
<span class="nb">println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">done</span><span class="p">)</span></code></pre></figure>

<p>This feature may be used for goroutines synchronization. Let’s recall one of our examples with synchronization (the one with <code class="language-plaintext highlighter-rouge">done</code> channel):</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>

     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="nb">println</span><span class="p">(</span><span class="s">"goroutine message"</span><span class="p">)</span>

          <span class="c">// We are only interested in the fact of sending itself, </span>
          <span class="c">// but not in data being sent.</span>
          <span class="n">done</span> <span class="o">&lt;-</span> <span class="no">true</span>
     <span class="p">}()</span>

     <span class="nb">println</span><span class="p">(</span><span class="s">"main function message"</span><span class="p">)</span>
     <span class="o">&lt;-</span><span class="n">done</span> 
<span class="p">}</span> </code></pre></figure>

<p>Here the <code class="language-plaintext highlighter-rouge">done</code> channel is only used to synchronize the execution but not for sending data. There is a kind of pattern for such cases:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="c">// Data is irrelevant</span>
     <span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>

     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="nb">println</span><span class="p">(</span><span class="s">"goroutine message"</span><span class="p">)</span>

          <span class="c">// Just send a signal "I'm done"</span>
          <span class="nb">close</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
     <span class="p">}()</span>

     <span class="nb">println</span><span class="p">(</span><span class="s">"main function message"</span><span class="p">)</span>
     <span class="o">&lt;-</span><span class="n">done</span>
<span class="p">}</span> </code></pre></figure>

<p>As we close the channel in the goroutine the reading operation does not block and the main function continues to run.</p>

<h2 id="multiple-channels-and-select">Multiple channels and select<a class="header-link" href="#multiple-channels-and-select"><i class="fa fa-link"></i></a></h2>

<p>In real programs you’ll probably need more than one goroutine and one
 channel. The more independent parts are - the more need for effective 
synchronization. Let’s look at more complex example:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">getMessagesChannel</span><span class="p">(</span><span class="n">msg</span> <span class="kt">string</span><span class="p">,</span> <span class="n">delay</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">string</span> <span class="p">{</span>
     <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span>
     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
               <span class="n">c</span> <span class="o">&lt;-</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%s %d"</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
               <span class="c">// Wait before sending next message</span>
               <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span> <span class="o">*</span> <span class="n">delay</span><span class="p">)</span>
          <span class="p">}</span>
     <span class="p">}()</span>
     <span class="k">return</span> <span class="n">c</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">c1</span> <span class="o">:=</span> <span class="n">getMessagesChannel</span><span class="p">(</span><span class="s">"first"</span><span class="p">,</span> <span class="m">300</span><span class="p">)</span>
     <span class="n">c2</span> <span class="o">:=</span> <span class="n">getMessagesChannel</span><span class="p">(</span><span class="s">"second"</span><span class="p">,</span> <span class="m">150</span><span class="p">)</span>
     <span class="n">c3</span> <span class="o">:=</span> <span class="n">getMessagesChannel</span><span class="p">(</span><span class="s">"third"</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>

     <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
          <span class="nb">println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">c1</span><span class="p">)</span>
          <span class="nb">println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">c2</span><span class="p">)</span>
          <span class="nb">println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">c3</span><span class="p">)</span>
     <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Here we have a function that creates a channel and spawns a goroutine
 which will populate the channel with three messages in a specified 
interval. As we see the third channel <code class="language-plaintext highlighter-rouge">c3</code> has the least interval, thus we except its messages to appear prior to others. But the output will be the following:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">first 1
second 1
third 1
first 2
second 2
third 2
first 3
second 3
third 3</code></pre></figure>

<p>Obviously we got a successive output. That is because the reading operation on the first channel blocks for <code class="language-plaintext highlighter-rouge">300</code>
 milliseconds for each loop iteration and other operations must wait. 
What we actually want is to read messages from all channels as soon as 
they are any.</p>

<p>For communication operations on multiple channels there is a <a href="http://golang.org/ref/spec#Select_statements">select</a> statement in Golang. It’s much like the usual <code class="language-plaintext highlighter-rouge">switch</code> but all cases here are communication operations (both reads and writes). If the operation in <code class="language-plaintext highlighter-rouge">case</code> can be performed than the corresponding block of code executes. So, to accomplish what we want, we have to write:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
     <span class="k">select</span> <span class="p">{</span>
     <span class="k">case</span> <span class="n">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c1</span><span class="o">:</span>
          <span class="nb">println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
	 <span class="k">case</span> <span class="n">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c2</span><span class="o">:</span>
          <span class="nb">println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
     <span class="k">case</span> <span class="n">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c3</span><span class="o">:</span>
          <span class="nb">println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
     <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Pay attention to the number <code class="language-plaintext highlighter-rouge">9</code>:
 for each of the channels there were 3 writing operations, that’s why I 
have to perform 9 loops of the select statement. In a program which is 
meant to run as a daemon there is a common practice to run <code class="language-plaintext highlighter-rouge">select</code> in an infinite loop, but here I’ll get a deadlock if I’ll run one.</p>

<p>Now we get the expected output, and non of reading operations block others. The output is:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">first 1
second 1
third 1 // this channel does not wait for others
third 2
third 3
second 2
first 2
second 3
first 3</code></pre></figure>

<h2 id="conclusion">Conclusion<a class="header-link" href="#conclusion"><i class="fa fa-link"></i></a></h2>

<p>Channels is a very powerful and interesting mechanism in Golang. But 
in order to use them effectively you have to understand how they work. 
In this article I tried to explain the very necessary basics. For 
further learning I recommend you look at the following:</p>

<ul>
  <li><a href="http://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not parallelism</a> - early mentioned talk from Rob Pike</li>
  <li><a href="http://www.youtube.com/watch?v=f6kdp27TYZs">Go Concurrency Patterns</a></li>
  <li><a href="http://www.youtube.com/watch?v=QDDwwePbDtw">Advanced Go Concurrency Patterns</a></li>
</ul>

</article>

<script type="text/javascript">
	var anchorForId = function (id) {
		var anchor = document.createElement("a");
		anchor.className = "header-link";
		anchor.href      = "#" + id;
		anchor.innerHTML = "<i class='fa fa-link'></i>";
		return anchor;
	};

	var linkifyAnchors = function (level, containingElement) {
		var headers = containingElement.getElementsByTagName("h" + level);
		for (var h = 0; h < headers.length; h++) {
			var header = headers[h];

			if (typeof header.id !== "undefined" && header.id !== "") {
				header.appendChild(anchorForId(header.id));
			}
		}
	};

	document.onreadystatechange = function () {
		if (this.readyState === "complete") {
			var contentBlock = document.getElementsByTagName("article")[0];
			if (!contentBlock) {
				return;
			}
			for (var level = 1; level <= 6; level++) {
				linkifyAnchors(level, contentBlock);
			}
		}
	};
</script>

	</section>

	
	<!--<h2>Comments</h2>-->
	<div id="disqus_thread"><iframe id="dsq-app5791" name="dsq-app5791" allowtransparency="true" scrolling="no" tabindex="0" title="Disqus" style="width: 1px !important; min-width: 100% !important; border: medium none !important; overflow: hidden !important; height: 673px !important;" src="Golang%20channels%20tutorial%20|%20Alexander%20Guz's%20blog_files/a.html" horizontalscrolling="no" verticalscrolling="no" width="100%" frameborder="0"></iframe></div>
	<script>
		var disqus_config = function () {
			this.page.url = 'https://guzalexander.com/2013/12/06/golang-channels-tutorial.html';
			this.page.identifier = '/2013/12/06/golang-channels-tutorial';
		};
		(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');
			s.src = 'https://kalimatas.disqus.com/embed.js';
			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
		})();
	</script>
	<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	

	<footer>
		<section class="copyright">© Copyright 2019 by Alexander Guz</section>
		<section class="contact">
			Contact me via <a href="mailto:guz@kalimatas.com">email</a>
		</section>
		<div class="clear"></div>
	</footer>
</section>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31916607-1']);
  _gaq.push(['_setDomainName', 'guzalexander.com']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



<iframe style="display: none;"></iframe></body></html>